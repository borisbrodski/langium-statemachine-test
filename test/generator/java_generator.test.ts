import { describe, expect, test } from "vitest";
import * as fs from 'node:fs';

import { URI, WorkspaceFolder } from "langium";
import { createStateMachineServices } from "../../src/language/state-machine-module.js";
import { Model } from "../../src/language/generated/ast.js";
import { generate } from "../../src/cli/generator.js";
import { NodeFileSystem } from "langium/node";
import path from "node:path";
import { GeneratedContent, GeneratorOutputCollector } from "langium-tools/generator";



// let services: ReturnType<typeof createStateMachineServices>;
// let parse: ReturnType<typeof parseHelper<Model>>;

// beforeAll(async () => {
//   services = createStateMachineServices(EmptyFileSystem);
//   parse = parseHelper<Model>(services.StateMachine);
//
//   // activate the following if your linking test requires elements from a built-in library, for example
//   // await services.shared.workspace.WorkspaceManager.initializeWorkspace([]);
// });

describe("Langium code generator tests", () => {

  // Iterate over all DSL files in dsls/ directory
  fs.readdirSync(__dirname, { withFileTypes: true })
    .filter((dirent) => dirent.isDirectory())
    .forEach((dirent) => {
      const testDirName = dirent.name;

      test(`DSL-Workspace "${testDirName}"`, async () => {
        const services = createStateMachineServices(NodeFileSystem)
        const workspaceManager = services.shared.workspace.WorkspaceManager;
        const LangiumDocuments = services.shared.workspace.LangiumDocuments;
        const DocumentBuilder = services.shared.workspace.DocumentBuilder;

        const workspaceFolder: WorkspaceFolder = {
          name: 'MyDSL Workspace',
          uri: URI.file(__dirname + "/" + testDirName + '/dsls').toString()
        };

        const outputDir = path.join(__dirname, testDirName, 'generated');

        await workspaceManager.initializeWorkspace([workspaceFolder]);

        // Access documents from LangiumDocuments
        const documents = LangiumDocuments.all.toArray();
        console.log(`Building workspace ${workspaceFolder.uri} with ${documents.length} DSLs`);
        await DocumentBuilder.build(documents);

        // Ensure there are no parser errors
        documents.forEach(doc => {
          expect(doc.parseResult.lexerErrors, `DSL file ${doc.uri} has lexer errors`).toHaveLength(0);
          expect(doc.parseResult.parserErrors, `DSL file ${doc.uri} has parser errors`).toHaveLength(0);
        });

        const outputCollecor = new GeneratorOutputCollector();
        documents.forEach(doc => {
          const model = doc.parseResult.value as Model;
          const relativeFileName = path.relative(workspaceFolder.uri, doc.uri.toString());
          generate(model, outputCollecor.generatorOutputFor(relativeFileName));
        });

        // // Check, that files doesn't get overwritten.  Add to the err msg both DSLs that are involved into the clash.
        // const fileMap = fileContentMapList.reduce<Map<string, number[]>>((acc, item, index) => {
        //   Array.from(item.keys()).reduce<Map<string, number[]>>((innerAcc, filename) => {
        //     if (!innerAcc.has(filename)) {
        //       innerAcc.set(filename, []);
        //     }
        //     innerAcc.get(filename)!.push(index);
        //     return innerAcc;
        //   }, acc);
        //
        //   return acc;
        // }, new Map<string, number[]>());
        //
        // const clashFiles = Array.from(fileMap.entries())
        //   .filter(([filename, indices]) => indices.length > 1)
        //   .map(([filename, indices]) => {
        //     return `${filename} is generated by DSLs: ${indices.map(index => documents[index].uri)}`;
        //   });
        //
        // expect(clashFiles, `Clash in generated files: ${clashFiles}`).toHaveLength(0);

        // Combine all file content maps into one
        // const fileContentMap = fileContentMapList.reduce((acc, item) => {
        //   item.forEach((content, filename) => {
        //     acc.set(filename, content);
        //   });
        //   return acc;
        // }, new Map<string, string>());




        // await workspaceManager.initializeWorkspace([dirOfThisTestFile + "/" + name + 'dsls']);
        //
        // // Get all LangiumDocuments
        // const documents = workspaceManager.all.map(uri => documentFactory.create(uri));
        //
        // // Build documents (parse, index, link)
        // await documentBuilder.build(documents, { validate: false });
        //
        // // Now you can access the documents and their parsed ASTs
        // documents.forEach(doc => {
        //   console.log(doc.parseResult.value); // AST root node
        // });
        // }

        // parseWorkspace().catch(console.error);
        // const fileContent = fs.readFileSync(dslsDir + "/" + dslFile, "utf-8");
        // const parseResult = await parse(fileContent);
        // expect(parseResult.parseResult.parserErrors).toHaveLength(0);
        // const model: Model = parseResult.parseResult.value;
        // const fileContentMap = generate(model, dslFile);
        //
        const generateMode = process.env.GENERATOR_TEST === "generate";

        if (generateMode) {
          cleanDir(outputDir);
          outputCollecor.writeToDisk(outputDir);
        } else {
          verifyFiles(outputCollecor.getGeneratedContent(), outputDir);
        }
        //
        // expect(true).toBe(true);
      });
    });

  // test("generateJavaScript", () => {
  //   // Create temp file with DSL contentt
  //   const destination = "test";
  //
  //   generateAction("test", { destination: "test" });
  //   expect(true).toBe(true);
  // });
});

/**
 * Clean output directory.
 *
 * Make sure not to delete files that are not generated by the generator
 * by checking sibling directories. The dsls directory should be present
 * in the same directory as the out directory.
 *
 * @param outputDir
 */
function cleanDir(outputDir: string) {
  if (!fs.existsSync(outputDir)) {
    return;
  }

  const siblingDirs = fs.readdirSync(`${outputDir}/..`);
  if (!siblingDirs.includes("dsls")) {
    throw new Error("The out directory ${outputDir} should have a sibling directory named 'dsls'");
  }
  const files = fs.readdirSync(outputDir);
  files.forEach((file) => {
    // console.log("Deleting file: ", file);
    fs.rmSync(outputDir + "/" + file, { recursive: true });
  });
}


// function createFiles(fileContentMap: Map<string, string>, baseDir: string) {
//   fileContentMap.forEach((content, fileName) => {
//     const filePath = baseDir + "/" + fileName;
//     // create dir if does not exists
//     const dir = filePath.substring(0, filePath.lastIndexOf("/"));
//     if (!fs.existsSync(dir)) {
//       fs.mkdirSync(dir, { recursive: true });
//     }
//     fs.writeFileSync(filePath, content);
//   })
// }

/**
 * Verify, that generated file structure matches exacly
 * with the existing files in the output directory.
 *
 * @param fileContentMap
 * @param outputDir
 */
function verifyFiles(content: GeneratedContent, outputDir: string) {
  const files = (fs.readdirSync(outputDir, { recursive: true }) as string[])
    .filter(file => fs.statSync(path.join(outputDir, file)).isFile());
  content.forEach((content, fileName) => {
    expect(files, "Unexpected generated file").toContain(fileName);
    const filePath = outputDir + "/" + fileName;
    const fileContent = fs.readFileSync(filePath, "utf-8");
    expect(fileContent, "File: " + fileName).toBe(content.content);
  });
  if (files.length !== content.size) {
    const missingFiles = Array.from(content.keys()).filter((file) => !files.includes(file));
    throw new Error("Missing files: " + missingFiles);
  }

}

